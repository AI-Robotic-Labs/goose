"use strict";(self.webpackChunkgoose=self.webpackChunkgoose||[]).push([[9257],{1962:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"errors","title":"Errors","description":"Error handling is a key performance-driving part of goose. There are many ways that the non-determinism","source":"@site/docs/errors.md","sourceDirName":".","slug":"/errors","permalink":"/goose/v1/docs/errors","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/errors.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Configuration","permalink":"/goose/v1/docs/configuration"},"next":{"title":"Instructions for running cross to test release builds locally","permalink":"/goose/v1/docs/run_cross_local"}}');var o=t(4848),s=t(8453);const a={},i="Errors",l={},c=[{value:"Traditional Errors",id:"traditional-errors",level:2},{value:"Agent Errors",id:"agent-errors",level:2}];function h(e){const r={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"errors",children:"Errors"})}),"\n",(0,o.jsxs)(r.p,{children:["Error handling is a key performance-driving part of ",(0,o.jsx)(r.code,{children:"goose"}),". There are many ways that the non-determinism\nin the LLM can introduce an error that it can in turn recover from. In a typical goose session, its expected for there\nto be several agent errors that the model can see directly and correct, perhaps entirely behind the scenes."]}),"\n",(0,o.jsx)(r.h2,{id:"traditional-errors",children:"Traditional Errors"}),"\n",(0,o.jsx)(r.p,{children:"While the agent is operating, there can be intermittent issues in the network, availability of the\nfoundational model, etc. These are raised as errors in the agent API to the caller, who can decide\nhow to handle that. We generally handle these with anyhow::Error."}),"\n",(0,o.jsx)(r.h2,{id:"agent-errors",children:"Agent Errors"}),"\n",(0,o.jsx)(r.p,{children:"There are several types of errors where everything is working correctly, but the model generations\nthemselves are somehow causing errors. Things like generating an unknown tool name, incorrect parameters,\nor a well formed tool call that results in an error in the tool itself. All of these can be surfaced to\nthe LLM to have it attempt to recover."}),"\n",(0,o.jsx)(r.p,{children:"The error messages are in some ways prompting - they give instructions to the LLM on how it might go\nabout recovering. We handle these with thiserror::Error and carefully maintain a collection."}),"\n",(0,o.jsxs)(r.p,{children:["To cover all these cases, both ToolUse and ToolResult are typically passed through the api as part of a\n",(0,o.jsx)(r.code,{children:"Result<T, AgentError>"}),". An error in a ToolUse will immediately become an error in a ToolResult and\npassed back to the LLM. A valid ToolUse might still end up in an error ToolResult, which is also passed\nback to the LLM."]}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.code,{children:"provider"}),"s then handle translating the agent errors into the various API specs as\nvalid messages.."]})]})}function d(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>a,x:()=>i});var n=t(6540);const o={},s=n.createContext(o);function a(e){const r=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:r},e.children)}}}]);