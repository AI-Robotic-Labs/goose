use anyhow::{Result, anyhow, Result as AnyhowResult};
use futures::stream::BoxStream;
use serde_json::{json, Value};
use tokio::sync::watch;
use tokio_stream::wrappers::ReceiverStream;
use std::collections::HashMap;
use std::sync::Arc;

use crate::errors::{AgentError, AgentResult};
use crate::models::content::Content;
use crate::models::message::{Message, ToolRequest};
use crate::models::tool::{Tool, ToolCall};
use crate::prompt_template::load_prompt_file;
use crate::providers::base::Provider;
use crate::systems::{System, CancellableOperation, CancelFn};
use serde::Serialize;

#[derive(Clone, Debug, Serialize)]
struct SystemInfo {
    name: String,
    description: String,
    instructions: String,
}

impl SystemInfo {
    fn new(name: &str, description: &str, instructions: &str) -> Self {
        Self {
            name: name.to_string(),
            description: description.to_string(),
            instructions: instructions.to_string(),
        }
    }
}

#[derive(Clone, Debug, Serialize)]
struct SystemStatus {
    name: String,
    status: String,
}

impl SystemStatus {
    fn new(name: &str, status: String) -> Self {
        Self {
            name: name.to_string(),
            status,
        }
    }
}

/// Agent integrates a foundational LLM with the systems it needs to pilot
pub struct Agent {
    systems: Vec<Box<dyn System>>,
    provider: Arc<Box<dyn Provider>>,
}

impl Agent {
    /// Create a new Agent with the specified provider
    pub fn new(provider: Box<dyn Provider>) -> Self {
        Self {
            systems: Vec::new(),
            provider: Arc::new(provider),
        }
    }

    /// Add a system to the agent
    pub fn add_system(&mut self, system: Box<dyn System>) {
        self.systems.push(system);
    }

    /// Get all tools from all systems with proper system prefixing
    fn get_prefixed_tools(&self) -> Vec<Tool> {
        let mut tools = Vec::new();
        for system in self.systems.iter() {
            for tool in system.tools() {
                tools.push(Tool::new(
                    format!("{}__{}", system.name(), tool.name),
                    &tool.description,
                    tool.input_schema.clone(),
                ));
            }
        }
        tools
    }

    fn get_system_prompt(&self) -> AgentResult<String> {
        let mut context = HashMap::new();
        let systems_info: Vec<SystemInfo> = self
            .systems
            .iter()
            .map(|system| {
                SystemInfo::new(system.name(), system.description(), system.instructions())
            })
            .collect();

        context.insert("systems", systems_info);
        load_prompt_file("system.md", &context).map_err(|e| AgentError::Internal(e.to_string()))
    }

    /// Create a stream that yields each message as it's generated by the agent.
    /// This includes both the assistant's responses and any tool responses.
    ///
    /// To stop the agent mid-flight, the caller needs to drop the stream.
    pub async fn reply(&self, messages: &[Message], cancel_rx: watch::Receiver<bool>) -> Result<BoxStream<'_, Result<Message>>> {
        let systems = self.systems.clone();
        let provider = Arc::clone(&self.provider);
        let mut messages = messages.to_vec();
        let tools = self.get_prefixed_tools();
        let system_prompt = self.get_system_prompt()?;

        // Update conversation history for the start of the reply
        let status = get_system_status(&self.systems).await?;
        rewrite_messages_on_reply(&mut messages, status)
            .await?;

        // The message channel is used to send messages back to the caller via a stream at the end of this function.
        // The channel has size 1 so the agent only gets at most 1 step ahead of what the user sees.
        let (message_tx, message_rx) = tokio::sync::mpsc::channel(1);

        tokio::spawn(async move {
            let mut cancel_rx = cancel_rx.clone();
            loop {
                // Get completion from provider
                let (response, _) = match provider.complete(
                    &system_prompt,
                    &messages,
                    &tools,
                ).await {
                    Ok(r) => r,
                    Err(e) => {
                        if !message_tx.is_closed() {
                            message_tx.send(Err(anyhow!(e))).await.unwrap();
                        }
                        break;
                    }
                };

                // The assistant's response is added in rewrite_messages_on_tool_response
                // Yield the assistant's response
                if message_tx.is_closed() { break; }
                message_tx.send(Ok(response.clone())).await.unwrap();

                tokio::task::yield_now().await;

                // First collect any tool requests
                let tool_requests: Vec<&ToolRequest> = response.content
                    .iter()
                    .filter_map(|content| content.as_tool_request())
                    .collect();

                if tool_requests.is_empty() {
                    // No more tool calls, end the reply loop
                    break;
                }

                // Then dispatch each in parallel
                let futures: Vec<_> = tool_requests
                    .iter()
                    .map(|request| {
                        let op = dispatch_tool_call(&systems, request.tool_call.clone());
                        async move {
                            match op.await {
                                Ok(op) => Ok((op.future, op.cancel)),
                                Err(e) => Err(e),
                            }
                        }
                    })
                    .collect();

                let mut future_vec = Vec::new();
                let mut cancel_vec = Vec::new();

                for res in futures::future::join_all(futures).await {
                    match res {
                        Ok((future, cancel)) => {
                            future_vec.push(future);
                            cancel_vec.push(cancel);
                        }
                        Err(e) => {
                            if !message_tx.is_closed() {
                                message_tx.send(Err(anyhow!(e))).await.unwrap();
                            }
                            break;
                        }
                    }
                }

                // let outputs = futures::future::join_all(future_vec).await;
                let outputs = tokio::select! {
                    outputs = futures::future::join_all(future_vec) => outputs,
                    _ = cancel_rx.changed() => {
                        for cancel in cancel_vec {
                            cancel();
                        }
                        break;
                    }
                };

                // Create a message with the responses
                let mut message_tool_response = Message::user();
                // Now combine these into MessageContent::ToolResponse using the original ID
                for (request, output) in tool_requests.iter().zip(outputs.into_iter()) {
                    message_tool_response = message_tool_response.with_tool_response(
                        request.id.clone(),
                        output,
                    );
                }

                if message_tx.is_closed() { break; }
                message_tx.send(Ok(message_tool_response.clone())).await.unwrap();

                // Update conversation history after the tool call round
                let status = match get_system_status(&systems).await {
                    Ok(s) => s,
                    Err(e) => {
                        if !message_tx.is_closed() {
                            message_tx.send(Err(anyhow!(e))).await.unwrap();
                        }
                        break;
                    }
                };

                match rewrite_messages_on_tool_response(
                    &mut messages,
                    vec![response.clone(), message_tool_response],
                    status,
                ).await {
                    Ok(_) => (),
                    Err(e) => {
                        if !message_tx.is_closed() {
                            message_tx.send(Err(anyhow!(e))).await.unwrap();
                        }
                        break;
                    }
                };
            }
        });
        Ok(Box::pin(ReceiverStream::new(message_rx)))        
    }
}

//////
/// Message rewriting functions
//////

// Initialize a new reply round, which may call multiple tools
async fn rewrite_messages_on_reply(
    messages: &mut Vec<Message>,
    status: String,
) -> AgentResult<()> {
    // Create tool use message for status check
    let message_use =
        Message::assistant().with_tool_request("000", Ok(ToolCall::new("status", json!({}))));

    // Create tool result message with status
    let message_result =
        Message::user().with_tool_response("000", Ok(vec![Content::text(status)]));

    messages.push(message_use);
    messages.push(message_result);
    Ok(())
}

// Rewrite the exchange as needed after each tool call
async fn rewrite_messages_on_tool_response(
    messages: &mut Vec<Message>,
    pending: Vec<Message>,
    status: String,
) -> AgentResult<()> {
    // Remove the last two messages (status and tool response)
    messages.pop();
    messages.pop();

    // Append the pending messages
    messages.extend(pending);

    // Add back a fresh status and tool response
    let message_use =
        Message::assistant().with_tool_request("000", Ok(ToolCall::new("status", json!({}))));

    let message_result =
        Message::user().with_tool_response("000", Ok(vec![Content::text(status)]));

    messages.push(message_use);
    messages.push(message_result);

    Ok(())
}

//////
/// Functions primarily operating on systems.
//////

/// Find the appropriate system for a tool call based on the prefixed name
fn get_system_for_tool<'a>(systems: &'a Vec<Box<dyn System>>, prefixed_name: &'a  str) -> Option<&'a Box<dyn System>> {
    let parts: Vec<&str> = prefixed_name.split("__").collect();
    if parts.len() != 2 {
        return None;
    }
    let system_name = parts[0];
    systems
        .iter()
        .find(|sys| sys.name() == system_name)
}

/// Dispatch a single tool call to the appropriate system
async fn dispatch_tool_call(
    systems: &Vec<Box<dyn System>>,
    tool_call: AgentResult<ToolCall>,
) -> Result<CancellableOperation> {
    let call = tool_call?;
    let system = get_system_for_tool(systems, &call.name)
        .ok_or_else(|| AgentError::ToolNotFound(call.name.clone()))?;

    let tool_name = call
        .name
        .split("__")
        .nth(1)
        .ok_or_else(|| AgentError::InvalidToolName(call.name.clone()))?;
    let system_tool_call = ToolCall::new(tool_name, call.arguments);

    // Get the cancellable operation
    Ok(system.call(system_tool_call).await)
    // let op = system.call(system_tool_call).await;
    // Execute the future
    // op.future.await
}

/// Fetches the current status of all systems and formats it as a status message
async fn get_system_status(systems: &Vec<Box<dyn System>>) -> AgentResult<String> {
    // Get status of all systems
    let status = if !systems.is_empty() {
        let mut context = HashMap::new();
        let mut systems_status: Vec<SystemStatus> = Vec::new();
        for system in systems.iter() {
            let system_status = system
                .status()
                .await
                .map_err(|e| AgentError::Internal(e.to_string()))?;

            // Format the status into a readable string
            let status_str = serde_json::to_string(&system_status).unwrap_or_default();

            systems_status.push(SystemStatus::new(system.name(), status_str));
        }
        context.insert("systems", systems_status);
        load_prompt_file("status.md", &context)
            .map_err(|e| AgentError::Internal(e.to_string()))?
    } else {
        "No systems loaded".to_string()
    };

    Ok(status)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::message::MessageContent;
    use crate::providers::mock::MockProvider;
    use async_trait::async_trait;
    use futures::TryStreamExt;
    use serde_json::json;
    use std::collections::HashMap;

    #[derive(Clone)]
    // Mock system for testing
    struct MockSystem {
        name: String,
        tools: Vec<Tool>,
    }

    impl MockSystem {
        fn new(name: &str) -> Self {
            Self {
                name: name.to_string(),
                tools: vec![Tool::new(
                    "echo",
                    "Echoes back the input",
                    json!({"type": "object", "properties": {"message": {"type": "string"}}, "required": ["message"]}),
                )],
            }
        }

        async fn echo(&self, params: Value) -> AgentResult<Vec<Content>> {
            let message = params
                .get("message")
                .and_then(|v| v.as_str())
                .ok_or_else(|| AgentError::InvalidParameters("message parameter required".into()))?;

            Ok(vec![Content::text(message)])
        }
    }

    #[async_trait]
    impl System for MockSystem {
        fn name(&self) -> &str {
            "echo"
        }

        fn description(&self) -> &str {
            "A simple system that echoes input back to the caller"
        }

        fn instructions(&self) -> &str {
            "Use the echo tool to get a response back with your input message"
        }

        fn tools(&self) -> &[Tool] {
            &self.tools
        }

        async fn status(&self) -> AnyhowResult<HashMap<String, Value>> {
            Ok(HashMap::new()) // Echo system has no state to report
        }

        async fn call(&self, tool_call: ToolCall) -> CancellableOperation {
            // Create a no-op cancel function since this system doesn't create long-running processes
            let cancel_fn: CancelFn = Arc::new(|| {});
            
            // Clone self and tool info since we need to move them into the future
            let this = self.clone();
            let tool_name = tool_call.name.clone();
            let arguments = tool_call.arguments.clone();
            
            // Create the future that will execute the tool call
            let future = Box::pin(async move {
                match tool_name.as_str() {
                    "echo" => this.echo(arguments).await,
                    _ => Err(AgentError::ToolNotFound(tool_name)),
                }
            });

            CancellableOperation {
                cancel: cancel_fn,
                future,
            }
        }
    }

    #[tokio::test]
    async fn test_simple_response() -> Result<()> {
        let response = Message::assistant().with_text("Hello!");
        let provider = MockProvider::new(vec![response.clone()]);
        let agent = Agent::new(Box::new(provider));

        let initial_message = Message::user().with_text("Hi");
        let initial_messages = vec![initial_message];

        let (_cancel_tx, cancel_rx) = tokio::sync::watch::channel(true);
        let mut stream = agent.reply(&initial_messages, cancel_rx).await?;
        let mut messages = Vec::new();
        while let Some(msg) = stream.try_next().await? {
            messages.push(msg);
        }

        assert_eq!(messages.len(), 1);
        assert_eq!(messages[0], response);
        Ok(())
    }

    #[tokio::test]
    async fn test_tool_call() -> Result<()> {
        let mut agent = Agent::new(Box::new(MockProvider::new(vec![
            Message::assistant().with_tool_request(
                "1",
                Ok(ToolCall::new("test_echo", json!({"message": "test"}))),
            ),
            Message::assistant().with_text("Done!"),
        ])));

        agent.add_system(Box::new(MockSystem::new("test")));

        let initial_message = Message::user().with_text("Echo test");
        let initial_messages = vec![initial_message];

        let (_cancel_tx, cancel_rx) = tokio::sync::watch::channel(true);
        let mut stream = agent.reply(&initial_messages, cancel_rx).await?;
        let mut messages = Vec::new();
        while let Some(msg) = stream.try_next().await? {
            messages.push(msg);
        }

        // Should have three messages: tool request, response, and model text
        assert_eq!(messages.len(), 3);
        assert!(messages[0]
            .content
            .iter()
            .any(|c| matches!(c, MessageContent::ToolRequest(_))));
        assert_eq!(messages[2].content[0], MessageContent::text("Done!"));
        Ok(())
    }

    #[tokio::test]
    async fn test_invalid_tool() -> Result<()> {
        let mut agent = Agent::new(Box::new(MockProvider::new(vec![
            Message::assistant()
                .with_tool_request("1", Ok(ToolCall::new("invalid_tool", json!({})))),
            Message::assistant().with_text("Error occurred"),
        ])));

        agent.add_system(Box::new(MockSystem::new("test")));

        let initial_message = Message::user().with_text("Invalid tool");
        let initial_messages = vec![initial_message];

        let (_cancel_tx, cancel_rx) = tokio::sync::watch::channel(true);
        let mut stream = agent.reply(&initial_messages, cancel_rx).await?;
        let mut messages = Vec::new();
        while let Some(msg) = stream.try_next().await? {
            messages.push(msg);
        }

        // Should have three messages: failed tool request, fail response, and model text
        assert_eq!(messages.len(), 3);
        assert!(messages[0]
            .content
            .iter()
            .any(|c| matches!(c, MessageContent::ToolRequest(_))));
        assert_eq!(
            messages[2].content[0],
            MessageContent::text("Error occurred")
        );
        Ok(())
    }

    #[tokio::test]
    async fn test_multiple_tool_calls() -> Result<()> {
        let mut agent = Agent::new(Box::new(MockProvider::new(vec![
            Message::assistant()
                .with_tool_request(
                    "1",
                    Ok(ToolCall::new("test_echo", json!({"message": "first"}))),
                )
                .with_tool_request(
                    "2",
                    Ok(ToolCall::new("test_echo", json!({"message": "second"}))),
                ),
            Message::assistant().with_text("All done!"),
        ])));

        agent.add_system(Box::new(MockSystem::new("test")));

        let initial_message = Message::user().with_text("Multiple calls");
        let initial_messages = vec![initial_message];

        let (_cancel_tx, cancel_rx) = tokio::sync::watch::channel(true);
        let mut stream = agent.reply(&initial_messages, cancel_rx).await?;
        let mut messages = Vec::new();
        while let Some(msg) = stream.try_next().await? {
            messages.push(msg);
        }

        // Should have three messages: tool requests, responses, and model text
        assert_eq!(messages.len(), 3);
        assert!(messages[0]
            .content
            .iter()
            .any(|c| matches!(c, MessageContent::ToolRequest(_))));
        assert_eq!(messages[2].content[0], MessageContent::text("All done!"));
        Ok(())
    }
}